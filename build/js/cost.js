/// <reference path="./all.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var nervous_array_1 = require('nervous-array');
(function (ECostStrategy) {
    ECostStrategy[ECostStrategy["Quadratic"] = 0] = "Quadratic";
    ECostStrategy[ECostStrategy["CrossEntropy"] = 1] = "CrossEntropy";
})(exports.ECostStrategy || (exports.ECostStrategy = {}));
var ECostStrategy = exports.ECostStrategy;
;
var CostStrategy = (function () {
    function CostStrategy(activationFunctions) {
        this.activationFunctions = activationFunctions;
    }
    CostStrategy.prototype.fn = function (data, yHat) {
        throw new Error("This method is not implemented.");
    };
    CostStrategy.prototype.delta = function (A, Z) {
        throw new Error("This method is not implemented.");
    };
    return CostStrategy;
})();
exports.CostStrategy = CostStrategy;
var QuadraticCost = (function (_super) {
    __extends(QuadraticCost, _super);
    function QuadraticCost() {
        _super.apply(this, arguments);
    }
    QuadraticCost.prototype.fn = function (data, yHat) {
        var cost = Math.pow(nervous_array_1.rootMeanSquare(nervous_array_1.sub(yHat, data)), 2);
        cost = 0.5 * cost;
        return cost;
    };
    QuadraticCost.prototype.delta = function (A, Z) {
        return A * this.activationFunctions.activationPrime(Z);
    };
    return QuadraticCost;
})(CostStrategy);
exports.QuadraticCost = QuadraticCost;
var CrossEntropyCost = (function (_super) {
    __extends(CrossEntropyCost, _super);
    function CrossEntropyCost() {
        _super.apply(this, arguments);
    }
    CrossEntropyCost.prototype.fn = function (data, yHat) {
        var cost = 0;
        function nanToNum(x) {
            if (isNaN(x)) {
                return 0;
            }
            return x;
        }
        for (var k = 0; k < data.length; k++) {
            var yOp = data, y1Op = nervous_array_1.addScalar(nervous_array_1.multiplyByScalar(data, -1), 1), yHatsLog = yHat.slice().map(function (x) { return Math.log(x); }), y1HatsLog = nervous_array_1.addScalar(nervous_array_1.multiplyByScalar(yHat.slice(), -1), 1).map(function (x) { return Math.log(x); });
            var term1 = nervous_array_1.multiply(yOp, yHatsLog), term2 = nervous_array_1.multiply(y1Op, y1HatsLog);
            var difference = nervous_array_1.multiplyByScalar(nervous_array_1.add(term1, term2), -1);
            difference.map(nanToNum);
            //sum(-y*log(a)-(1-y)*log(1-a))
            cost += nervous_array_1.sum(difference);
        }
        return cost;
    };
    CrossEntropyCost.prototype.delta = function (A, Z) {
        return A;
    };
    return CrossEntropyCost;
})(CostStrategy);
exports.CrossEntropyCost = CrossEntropyCost;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvc3QudHMiXSwibmFtZXMiOlsiRUNvc3RTdHJhdGVneSIsIkNvc3RTdHJhdGVneSIsIkNvc3RTdHJhdGVneS5jb25zdHJ1Y3RvciIsIkNvc3RTdHJhdGVneS5mbiIsIkNvc3RTdHJhdGVneS5kZWx0YSIsIlF1YWRyYXRpY0Nvc3QiLCJRdWFkcmF0aWNDb3N0LmNvbnN0cnVjdG9yIiwiUXVhZHJhdGljQ29zdC5mbiIsIlF1YWRyYXRpY0Nvc3QuZGVsdGEiLCJDcm9zc0VudHJvcHlDb3N0IiwiQ3Jvc3NFbnRyb3B5Q29zdC5jb25zdHJ1Y3RvciIsIkNyb3NzRW50cm9weUNvc3QuZm4iLCJDcm9zc0VudHJvcHlDb3N0LmZuLm5hblRvTnVtIiwiQ3Jvc3NFbnRyb3B5Q29zdC5kZWx0YSJdLCJtYXBwaW5ncyI6IkFBQUEsbUNBQW1DOzs7Ozs7O0FBRW5DLDhCQUFtRixlQUFlLENBQUMsQ0FBQTtBQUduRyxXQUFZLGFBQWE7SUFDdkJBLDJEQUFhQSxDQUFBQTtJQUNiQSxpRUFBZ0JBLENBQUFBO0FBQ2xCQSxDQUFDQSxFQUhXLHFCQUFhLEtBQWIscUJBQWEsUUFHeEI7QUFIRCxJQUFZLGFBQWEsR0FBYixxQkFHWCxDQUFBO0FBQUEsQ0FBQztBQUVGO0lBRUVDLHNCQUNZQSxtQkFBeUNBO1FBQXpDQyx3QkFBbUJBLEdBQW5CQSxtQkFBbUJBLENBQXNCQTtJQUdyREEsQ0FBQ0E7SUFFREQseUJBQUVBLEdBQUZBLFVBQUlBLElBQWNBLEVBQUVBLElBQWNBO1FBQ2hDRSxNQUFNQSxJQUFJQSxLQUFLQSxDQUFDQSxpQ0FBaUNBLENBQUNBLENBQUNBO0lBQ3JEQSxDQUFDQTtJQUVERiw0QkFBS0EsR0FBTEEsVUFBT0EsQ0FBU0EsRUFBRUEsQ0FBU0E7UUFDekJHLE1BQU1BLElBQUlBLEtBQUtBLENBQUNBLGlDQUFpQ0EsQ0FBQ0EsQ0FBQ0E7SUFDckRBLENBQUNBO0lBQ0hILG1CQUFDQTtBQUFEQSxDQWZBLEFBZUNBLElBQUE7QUFmWSxvQkFBWSxlQWV4QixDQUFBO0FB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LENBQUNBLElBQUlBLENBQUNBO0lBQ2RBLENBQUNBO0lBRURGLGdDQUFLQSxHQUFMQSxVQUFPQSxDQUFTQSxFQUFFQSxDQUFTQTtRQUN6QkksTUFBTUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDWEEsQ0FBQ0E7SUFDSEosdUJBQUNBO0FBQURBLENBcENBLEFBb0NDQSxFQXBDcUMsWUFBWSxFQW9DakQ7QUFwQ1ksd0JBQWdCLG1CQW9DNUIsQ0FBQSIsImZpbGUiOiJjb3N0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vYWxsLmQudHNcIiAvPlxuXG5pbXBvcnQge2FkZCwgc3ViLCBtdWx0aXBseUJ5U2NhbGFyLCBtdWx0aXBseSwgYWRkU2NhbGFyLCBzdW0sIHJvb3RNZWFuU3F1YXJlfSBmcm9tICduZXJ2b3VzLWFycmF5JztcbmltcG9ydCB7SUFjdGl2YXRpb25GdW5jdGlvbnN9IGZyb20gJy4vbmV1cmFsLW5ldHdvcmsnO1xuXG5leHBvcnQgZW51bSBFQ29zdFN0cmF0ZWd5IHtcbiAgUXVhZHJhdGljID0gMCwgXG4gIENyb3NzRW50cm9weSA9IDFcbn07XG5cbmV4cG9ydCBjbGFzcyBDb3N0U3RyYXRlZ3kge1xuICBcbiAgY29uc3RydWN0b3IgKFxuICAgIHByb3RlY3RlZCBhY3RpdmF0aW9uRnVuY3Rpb25zOiBJQWN0aXZhdGlvbkZ1bmN0aW9ucyAgXG4gICkge1xuICAgIFxuICB9XG4gIFxuICBmbiAoZGF0YTogbnVtYmVyW10sIHlIYXQ6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5gKTtcbiAgfVxuICBcbiAgZGVsdGEgKEE6IG51bWJlciwgWjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5gKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUXVhZHJhdGljQ29zdCBleHRlbmRzIENvc3RTdHJhdGVneSB7XG4gIGZuIChkYXRhOiBudW1iZXJbXSwgeUhhdDogbnVtYmVyW10pOiBudW1iZXIge1xuICAgICAgICBcbiAgICBsZXQgY29zdCA9IE1hdGgucG93KHJvb3RNZWFuU3F1YXJlKHN1Yih5SGF0LCBkYXRhKSksIDIpO1xuICAgICAgXG4gICAgY29zdCA9IDAuNSAqIGNvc3Q7XG4gICAgXG4gICAgcmV0dXJuIGNvc3Q7XG4gIH1cbiAgXG4gIGRlbHRhIChBOiBudW1iZXIsIFo6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIEEgKiB0aGlzLmFjdGl2YXRpb25GdW5jdGlvbnMuYWN0aXZhdGlvblByaW1lKFopO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDcm9zc0VudHJvcHlDb3N0IGV4dGVuZHMgQ29zdFN0cmF0ZWd5IHtcbiAgZm4gKGRhdGE6IG51bWJlcltdLCB5SGF0OiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgbGV0IGNvc3QgPSAwO1xuICAgIFxuICAgIGZ1bmN0aW9uIG5hblRvTnVtICh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIFxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgXG4gICAgICBsZXQgeU9wID0gZGF0YSxcbiAgICAgICAgICB5MU9wID0gYWRkU2NhbGFyKG11bHRpcGx5QnlTY2FsYXIoZGF0YSwgLTEpLCAxKSxcbiAgICAgICAgICB5SGF0c0xvZyA9IHlIYXQuc2xpY2UoKS5tYXAoeCA9PiBNYXRoLmxvZyh4KSksXG4gICAgICAgICAgeTFIYXRzTG9nID0gYWRkU2NhbGFyKG11bHRpcGx5QnlTY2FsYXIoeUhhdC5zbGljZSgpLCAtMSksIDEpLm1hcCh4ID0+IE1hdGgubG9nKHgpKTtcblxuICAgICAgbGV0IHRlcm0xID0gbXVsdGlwbHkoeU9wLCB5SGF0c0xvZyksXG4gICAgICAgICAgdGVybTIgPSBtdWx0aXBseSh5MU9wLCB5MUhhdHNMb2cpO1xuICAgICAgXG4gICAgICBsZXQgZGlmZmVyZW5jZSA9IG11bHRpcGx5QnlTY2FsYXIoYWRkKHRlcm0xLCB0ZXJtMiksIC0xKTtcbiAgICAgIFxuICAgICAgZGlmZmVyZW5jZS5tYXAobmFuVG9OdW0pO1xuICAgICAgXG4gICAgICAvL3N1bSgteSpsb2coYSktKDEteSkqbG9nKDEtYSkpXG4gICAgICBjb3N0ICs9IHN1bShkaWZmZXJlbmNlKTtcbiAgICAgIFxuICAgIH1cblxuICAgIHJldHVybiBjb3N0O1xuICB9XG4gIFxuICBkZWx0YSAoQTogbnVtYmVyLCBaOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBBO1xuICB9XG59Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9